@{
    Layout = null;
}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Dashboard</title>
    <style>
        /* Custom CSS Variables for Colors */
        :root {
            --dark-base: rgba(20,23,40,1);
            --dark-medium: rgba(35,42,81,1);
            --dark-light: rgba(60,73,151,1);
            --dark-blue-700: rgba(60,73,151,1);
            --dark-blue-800: rgba(35,42,81,1);
            --dark-blue-900: rgba(20,23,40,1);
            --dark-blue-950: #000033;
            --status-online: #90EE90;
            --status-offline: #FFB6C1;
            --gray-900: #111827;
            --slate-800: #1e293b;
        }

        /* Dashboard Styles */
        .dashboard {
            background-color: var(--gray-900);
            width: 120px;
            height: 240px;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .datetime-header {
            color: white;
            text-align: center;
            padding: 2px 0;
            margin-bottom: 2px;
            flex-shrink: 0;
            height: 24px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .current-time {
            font-size: 12px;
            font-weight: bold;
            color: #38bdf8;
            margin-bottom: 1px;
            line-height: 1;
        }

        .current-date {
            font-size: 8px;
            color: #94a3b8;
            font-weight: normal;
            line-height: 1;
        }

        .main-content-gap {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .right-column {
            color: white;
            display: flex;
            flex-direction: column;
            gap: 2px;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        .value-container {
            border-radius: 6px;
            background-color: var(--slate-800);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            width: 116px;
            height: 96px;
            padding: 4px;
            position: absolute;
            left: 2px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            pointer-events: none;
            z-index: 1;
        }

            .value-container:nth-child(1) {
                top: 0;
            }

            .value-container:nth-child(2) {
                top: 98px;
            }

            .value-container.visible {
                opacity: 1;
                transform: translateY(0) scale(1);
                pointer-events: auto;
                z-index: 10;
            }

            .value-container.transitioning-out {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
                pointer-events: none;
                z-index: 1;
            }

        .value-title {
            font-weight: bold;
            font-size: 9px;
            text-align: center;
            line-height: 1;
            height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            flex-shrink: 0;
        }

        .overlay-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 10;
            pointer-events: none;
        }

        .value-status {
            font-size: 7px;
            text-align: center;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            line-height: 1;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            flex-shrink: 0;
        }

        .status-good {
            background-color: #1e40af;
            color: white;
        }

        .status-moderate {
            background-color: #4d7c0f;
            color: white;
        }

        .status-unhealthy {
            background-color: #eab308;
            color: black;
        }

        .status-very-unhealthy {
            background-color: #ea580c;
            color: white;
        }

        .status-danger {
            background-color: #dc2626;
            color: white;
        }

        .status-loading {
            background-color: #6b7280;
            color: white;
        }

        .status-error {
            background-color: #dc2626;
            color: white;
        }

        .status-normal {
            background-color: #65a30d;
            color: white;
        }

        .status-out-of-range {
            background-color: #dc2626;
            color: white;
        }

        .status-optimal {
            background-color: #059669;
            color: white;
        }

        .status-low {
            background-color: #0ea5e9;
            color: white;
        }

        .status-high {
            background-color: #f59e0b;
            color: white;
        }

        /* Canvas specific styles */
        .canvas-container {
            position: relative;
            width: 108px;
            height: 60px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .visualization-canvas {
            width: 108px;
            height: 60px;
            border-radius: 4px;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
        }

        /* Page indicator */
        .page-indicator {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 3px;
            padding: 2px 0;
            height: 16px;
            flex-shrink: 0;
        }

        .page-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: #4b5563;
            transition: background-color 0.3s ease;
        }

            .page-dot.active {
                background-color: #38bdf8;
            }

        /* Reset default margins and padding */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 120px;
            height: 240px;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>
    <div id="dashboard" class="dashboard">
        <!-- DateTime Header -->
        <div class="datetime-header">
            <div class="current-time" id="currentTime">00:00:00</div>
            <div class="current-date" id="currentDate">Loading...</div>
        </div>

        <!-- Main Content -->
        <div class="main-content-gap">
            <!-- Right column -->
            <div class="right-column">
                <!-- Temperature Value Container -->
                <div class="value-container" id="temperatureContainer">
                    <div class="value-title">Temperature</div>
                    <div class="canvas-container">
                        <canvas id="temperatureCanvas" class="visualization-canvas" width="208" height="140"></canvas>
                        <div class="overlay-value" id="temperatureDisplayValue">--</div>
                    </div>
                    <div class="value-status status-loading" id="temperatureStatus">Loading</div>
                </div>

                <!-- Air Quality Value Container -->
                <div class="value-container" id="apiContainer">
                    <div class="value-title">Air Quality</div>
                    <div class="canvas-container">
                        <canvas id="apiCanvas" class="visualization-canvas" width="208" height="140"></canvas>
                        <div class="overlay-value" id="apiDisplayValue">--</div>
                    </div>
                    <div class="value-status status-loading" id="apiStatus">Loading</div>
                </div>

                <!-- Humidity Value Container -->
                <div class="value-container hidden" id="humidityContainer">
                    <div class="value-title">Humidity</div>
                    <div class="canvas-container">
                        <canvas id="humidityCanvas" class="visualization-canvas" width="208" height="140"></canvas>
                        <div class="overlay-value" id="humidityDisplayValue">--</div>
                    </div>
                    <div class="value-status status-loading" id="humidityStatus">Loading</div>
                </div>

                <!-- pH Value Container -->
                <div class="value-container hidden" id="phContainer">
                    <div class="value-title">pH Level</div>
                    <div class="canvas-container">
                        <canvas id="phCanvas" class="visualization-canvas" width="208" height="140"></canvas>
                        <div class="overlay-value" id="phDisplayValue">--</div>
                    </div>
                    <div class="value-status status-loading" id="phStatus">Loading</div>
                </div>

                <!-- Solar Value Container -->
                <div class="value-container hidden" id="solarContainer">
                    <div class="value-title">Solar Voltage</div>
                    <div class="canvas-container">
                        <canvas id="solarCanvas" class="visualization-canvas" width="208" height="140"></canvas>
                        <div class="overlay-value" id="solarDisplayValue">--</div>
                    </div>
                    <div class="value-status status-loading" id="solarStatus">Loading</div>
                </div>
            </div>
        </div>

        <!-- Page Indicator -->
        <div class="page-indicator">
            <div class="page-dot active" id="dot0"></div>
            <div class="page-dot" id="dot1"></div>
            <div class="page-dot" id="dot2"></div>
        </div>
    </div>

    <script>
        // Debug logging at the very start
        console.log('=== SCRIPT STARTED ===');
        console.log('Current URL:', window.location.href);
        console.log('Document ready state:', document.readyState);

        // Global variables for all sensors
        let sensorData = {
            temperature: { value: null, loading: true, currentLevel: 0, targetLevel: 0 },
            api: { value: null, loading: true, currentLevel: 0, targetLevel: 0 },
            humidity: { value: null, loading: true, currentLevel: 0, targetLevel: 0 },
            ph: { value: null, loading: true, currentLevel: 0, targetLevel: 0 },
            solar: { value: null, loading: true, currentLevel: 0, targetLevel: 0 }
        };

        // Animation variables
        let animationTime = 0;
        let animationRunning = false;

        // DateTime update variables
        let dateTimeInterval;

        // Page flipping variables
        let currentPage = 0;
        let flipInterval;
        let isTransitioning = false;
        const FLIP_DELAY = 5000; // 5 seconds per page
        const TRANSITION_DURATION = 400; // Match CSS transition duration

        // Configuration monitoring variables
        let configCheckInterval;
        let lastConfigTimestamp = 0;

        // Device IDs
        const monsantoAirKeyId = "5b2d5740-e441-11ef-96e7-17bd8bdd3393";
        const monsantoPhKeyId = "5b506fa0-e441-11ef-96e7-17bd8bdd3393";
        const monsantoSolarKeyId = "5b5837d0-e441-11ef-96e7-17bd8bdd3393";

        // Define sensor groups (2 sensors per page)
        const sensorPages = [
            ['temperature', 'api'],       // Page 0
            ['humidity', 'ph'],           // Page 1
            ['solar', 'temperature']      // Page 2 (cycling back to show solar with temperature)
        ];

        // Check if all required elements exist
        function checkRequiredElements() {
            console.log('=== CHECKING HTML ELEMENTS ===');

            const requiredElements = [
                'dashboard',
                'currentTime',
                'currentDate',
                'temperatureContainer',
                'temperatureCanvas',
                'temperatureDisplayValue',
                'temperatureStatus',
                'apiContainer',
                'apiCanvas',
                'apiDisplayValue',
                'apiStatus',
                'humidityContainer',
                'humidityCanvas',
                'humidityDisplayValue',
                'humidityStatus',
                'phContainer',
                'phCanvas',
                'phDisplayValue',
                'phStatus',
                'solarContainer',
                'solarCanvas',
                'solarDisplayValue',
                'solarStatus',
                'dot0',
                'dot1',
                'dot2'
            ];

            let allElementsFound = true;

            requiredElements.forEach(elementId => {
                const element = document.getElementById(elementId);
                if (element) {
                    console.log(`✓ Found element: ${elementId}`);
                } else {
                    console.error(`✗ Missing element: ${elementId}`);
                    allElementsFound = false;
                }
            });

            console.log('All elements found:', allElementsFound);
            return allElementsFound;
        }

        // Helper function to draw circle shape with bounds checking
        function drawCircleShape(ctx, centerX, centerY, radius) {
            // Ensure radius is positive and reasonable
            const safeRadius = Math.max(0.1, Math.min(radius, 100));

            ctx.beginPath();
            ctx.arc(centerX, centerY, safeRadius, 0, Math.PI * 2);
            ctx.closePath();
            return ctx;
        }

        // Helper function to create animated water fill with bounds checking
        function drawWaterFill(ctx, centerX, centerY, radius, waterLevel, primaryColor, time) {
            if (waterLevel <= 0 || radius <= 0) return;

            // Ensure safe radius
            const safeRadius = Math.max(1, radius);

            const waterHeight = safeRadius * 2 * waterLevel;
            const waterTop = centerY + safeRadius - waterHeight;

            const waveAmplitude = Math.min(2, safeRadius * 0.1);
            const waveFrequency = 0.02;
            const waveSpeed = 0.05;

            try {
                ctx.beginPath();

                const steps = Math.max(20, Math.min(100, safeRadius * 2));
                for (let i = 0; i <= steps; i++) {
                    const x = centerX - safeRadius + (safeRadius * 2 * i / steps);
                    const distanceFromCenter = Math.abs(x - centerX);

                    const maxDistanceAtY = Math.sqrt(Math.max(0, safeRadius * safeRadius - Math.pow(waterTop - centerY, 2)));
                    if (distanceFromCenter <= maxDistanceAtY) {
                        const wave = Math.sin(x * waveFrequency + time * waveSpeed) * waveAmplitude;
                        const y = waterTop + wave;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                }

                const waterBottom = centerY + safeRadius;
                ctx.lineTo(centerX + safeRadius, waterBottom);
                ctx.arc(centerX, centerY, safeRadius, 0, Math.PI);
                ctx.lineTo(centerX - safeRadius, waterTop);
                ctx.closePath();

                const gradient = ctx.createLinearGradient(0, waterTop, 0, centerY + safeRadius);
                const alpha1 = 0.6 + Math.sin(time * 0.02) * 0.1;
                const alpha2 = 0.8 + Math.sin(time * 0.02 + Math.PI/2) * 0.1;
                const alpha3 = 1.0;

                gradient.addColorStop(0, primaryColor + Math.floor(alpha1 * 255).toString(16).padStart(2, '0'));
                gradient.addColorStop(0.5, primaryColor + Math.floor(alpha2 * 255).toString(16).padStart(2, '0'));
                gradient.addColorStop(1, primaryColor + Math.floor(alpha3 * 255).toString(16).padStart(2, '0'));

                ctx.fillStyle = gradient;
                ctx.fill();

                // Highlight effect
                ctx.beginPath();
                const highlightY = waterTop + Math.sin(time * 0.03) * 1;
                const highlightWidth = safeRadius * 0.6;
                if (highlightWidth > 0) {
                    ctx.ellipse(centerX, highlightY, highlightWidth, 3, 0, 0, Math.PI * 2);
                    const highlightAlpha = 0.3 + Math.sin(time * 0.04) * 0.1;
                    ctx.fillStyle = primaryColor + Math.floor(highlightAlpha * 255).toString(16).padStart(2, '0');
                    ctx.fill();
                }
            } catch (error) {
                console.error('Error in drawWaterFill:', error);
            }

            return ctx;
        }

        // Canvas drawing functions with high DPI support
        function setupHighDPICanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // Set fixed canvas size
            const canvasWidth = 108;
            const canvasHeight = 60;

            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;

            ctx.scale(dpr, dpr);
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';

            return ctx;
        }

        // Status and color functions for each sensor type
        function getTemperatureStatus(val) {
            if (sensorData.temperature.loading || val === null) return 'Loading';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return 'Error';
            if (numVal < 18 || numVal > 30) return 'Out of Range';
            if (numVal >= 20 && numVal <= 26) return 'Optimal';
            return 'Normal';
        }

        function getTemperatureColor(val) {
            if (sensorData.temperature.loading || val === null) return '#6b7280';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return '#dc2626';
            if (numVal < 18) return '#0ea5e9';
            if (numVal > 30) return '#dc2626';
            if (numVal >= 20 && numVal <= 26) return '#059669';
            return '#f59e0b';
        }

        function getApiStatus(val) {
            if (sensorData.api.loading || val === null) return 'Loading';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return 'Error';
            if (numVal <= 50) return 'Good';
            if (numVal <= 100) return 'Moderate';
            if (numVal <= 200) return 'Unhealthy';
            if (numVal <= 300) return 'Very Unhealthy';
            return 'Danger';
        }

        function getApiColor(val) {
            if (sensorData.api.loading || val === null) return '#6b7280';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return '#dc2626';
            if (numVal <= 50) return '#0ea5e9';
            if (numVal <= 100) return '#059669';
            if (numVal <= 200) return '#f59e0b';
            if (numVal <= 300) return '#ea580c';
            return '#dc2626';
        }

        function getHumidityStatus(val) {
            if (sensorData.humidity.loading || val === null) return 'Loading';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return 'Error';
            if (numVal < 30) return 'Low';
            if (numVal > 70) return 'High';
            if (numVal >= 40 && numVal <= 60) return 'Optimal';
            return 'Normal';
        }

        function getHumidityColor(val) {
            if (sensorData.humidity.loading || val === null) return '#6b7280';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return '#dc2626';
            if (numVal < 30) return '#ea580c';
            if (numVal > 70) return '#0ea5e9';
            if (numVal >= 40 && numVal <= 60) return '#059669';
            return '#f59e0b';
        }

        function getPhStatus(val) {
            if (sensorData.ph.loading || val === null) return 'Loading';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return 'Error';
            if (numVal < 6 || numVal > 9) return 'Out of Range';
            return 'Normal';
        }

        function getPhColor(val) {
            if (sensorData.ph.loading || val === null) return '#6b7280';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return '#dc2626';
            if (numVal < 6 || numVal > 9) return '#dc2626';
            return '#059669';
        }

        function getSolarStatus(val) {
            if (sensorData.solar.loading || val === null) return 'Loading';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return 'Error';
            if (numVal < 11) return 'Low';
            if (numVal > 14) return 'High';
            return 'Normal';
        }

        function getSolarColor(val) {
            if (sensorData.solar.loading || val === null) return '#6b7280';
            const numVal = parseFloat(val);
            if (isNaN(numVal)) return '#dc2626';
            if (numVal < 11) return '#ea580c';
            if (numVal > 14) return '#dc2626';
            return '#f59e0b';
        }

        function getStatusClass(status) {
            const statusKey = status.toLowerCase().replace(' ', '-');
            return `status-${statusKey}`;
        }

        // Get status and color functions by sensor type
        function getSensorStatus(sensorType, value) {
            switch (sensorType) {
                case 'temperature': return getTemperatureStatus(value);
                case 'api': return getApiStatus(value);
                case 'humidity': return getHumidityStatus(value);
                case 'ph': return getPhStatus(value);
                case 'solar': return getSolarStatus(value);
                default: return 'Error';
            }
        }

        function getSensorColor(sensorType, value) {
            switch (sensorType) {
                case 'temperature': return getTemperatureColor(value);
                case 'api': return getApiColor(value);
                case 'humidity': return getHumidityColor(value);
                case 'ph': return getPhColor(value);
                case 'solar': return getSolarColor(value);
                default: return '#dc2626';
            }
        }

        function getSensorUnit(sensorType) {
            switch (sensorType) {
                case 'temperature': return '°C';
                case 'humidity': return '%';
                case 'solar': return 'V';
                default: return '';
            }
        }

        // Generic visualization drawing function
        function drawVisualization(canvasId, sensorType, timeOffset = 0) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas ${canvasId} not found!`);
                return;
            }

            const ctx = setupHighDPICanvas(canvas);

            // Fixed canvas dimensions
            const canvasWidth = 108;
            const canvasHeight = 60;
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            const sensor = sensorData[sensorType];
            if (!sensor) {
                console.error(`Sensor data for ${sensorType} not found`);
                return;
            }

            const val = parseFloat(sensor.value);

            let primaryColor, fillColor, targetLevel;

            if (sensor.loading || sensor.value === null) {
                primaryColor = '#6b7280';
                fillColor = '#6b7280';
                targetLevel = 0.3;
            } else if (isNaN(val)) {
                primaryColor = '#dc2626';
                fillColor = '#dc2626';
                targetLevel = 0.5;
            } else {
                primaryColor = getSensorColor(sensorType, sensor.value);
                fillColor = primaryColor;

                switch (sensorType) {
                    case 'temperature':
                        targetLevel = Math.max(0.05, Math.min(0.95, (val + 10) / 50));
                        break;
                    case 'api':
                        targetLevel = val <= 50 ? 0.9 : val <= 100 ? 0.7 : val <= 200 ? 0.5 : val <= 300 ? 0.3 : 0.15;
                        break;
                    case 'humidity':
                        targetLevel = Math.max(0.05, Math.min(0.95, val / 100));
                        break;
                    case 'ph':
                        targetLevel = Math.max(0.05, Math.min(0.95, val / 14));
                        break;
                    case 'solar':
                        targetLevel = Math.max(0.05, Math.min(0.95, val / 20));
                        break;
                    default:
                        targetLevel = 0.5;
                }
            }

            if (Math.abs(sensor.targetLevel - targetLevel) > 0.01) {
                sensor.targetLevel = targetLevel;
            }

            sensor.currentLevel += (sensor.targetLevel - sensor.currentLevel) * 0.05;

            // Calculate radius for 108x60 canvas
            const radius = 25; // Fixed radius for consistent appearance

            try {
                const pulseEffect = 1 + Math.sin(animationTime * 0.03 + timeOffset) * 0.1;
                const strokeRadius = radius * pulseEffect;

                drawCircleShape(ctx, centerX, centerY, strokeRadius);
                ctx.strokeStyle = primaryColor;
                ctx.lineWidth = Math.max(1, Math.min(3 * pulseEffect, 4));
                ctx.stroke();

                ctx.save();
                const clipRadius = radius - 2;
                drawCircleShape(ctx, centerX, centerY, clipRadius);
                ctx.clip();

                if (sensor.currentLevel > 0) {
                    drawWaterFill(ctx, centerX, centerY, clipRadius, sensor.currentLevel, fillColor, animationTime + timeOffset);
                }

                ctx.restore();

                // Shadow effect
                ctx.save();
                ctx.globalAlpha = 0.1;
                ctx.translate(1, 1);
                drawCircleShape(ctx, centerX, centerY, radius);
                ctx.fillStyle = '#000000';
                ctx.fill();
                ctx.restore();

            } catch (error) {
                console.error(`Error drawing visualization for ${canvasId}:`, error);
            }
        }

        // Page flipping functions
        function showPage(pageIndex) {
            if (isTransitioning || pageIndex === currentPage) {
                console.log('Transition in progress or same page, skipping...');
                return;
            }

            console.log(`Transitioning from page ${currentPage} to page ${pageIndex}`);
            isTransitioning = true;

            // Get all containers
            const allContainers = document.querySelectorAll('.value-container');

            // Phase 1: Hide current containers
            allContainers.forEach(container => {
                container.classList.remove('visible');
                container.classList.add('transitioning-out');
            });

            // Update page indicator immediately
            for (let i = 0; i < sensorPages.length; i++) {
                const dot = document.getElementById(`dot${i}`);
                if (dot) {
                    if (i === pageIndex) {
                        dot.classList.add('active');
                    } else {
                        dot.classList.remove('active');
                    }
                }
            }

            // Phase 2: After transition out, reset and show new containers
            setTimeout(() => {
                // Reset all containers to hidden state
                allContainers.forEach(container => {
                    container.classList.remove('transitioning-out', 'visible');
                });

                // Show containers for new page
                const currentPageSensors = sensorPages[pageIndex];
                currentPageSensors.forEach((sensorType, index) => {
                    const containerId = sensorType + 'Container';
                    const container = document.getElementById(containerId);
                    if (container) {
                        // Stagger the appearance for smooth effect
                        setTimeout(() => {
                            container.classList.add('visible');
                        }, index * 100);
                    }
                });

                currentPage = pageIndex;

                // Phase 3: Complete transition
                setTimeout(() => {
                    isTransitioning = false;
                    console.log(`Transition to page ${pageIndex} complete`);
                }, TRANSITION_DURATION + 200); // Extra buffer for staggered animations

            }, TRANSITION_DURATION);
        }

        function nextPage() {
            if (isTransitioning) {
                console.log('Transition in progress, skipping page flip');
                return;
            }
            const nextPageIndex = (currentPage + 1) % sensorPages.length;
            showPage(nextPageIndex);
        }

        function startPageFlipping() {
            console.log('Starting page flipping...');
            if (flipInterval) {
                clearInterval(flipInterval);
            }
            flipInterval = setInterval(() => {
                if (!isTransitioning) {
                    nextPage();
                }
            }, FLIP_DELAY);
        }

        function stopPageFlipping() {
            if (flipInterval) {
                clearInterval(flipInterval);
                flipInterval = null;
            }
        }

        function updateUI() {
            console.log('Updating UI...');
            // Update all sensor displays
            Object.keys(sensorData).forEach(sensorType => {
                const sensor = sensorData[sensorType];
                const displayElement = document.getElementById(sensorType + 'DisplayValue');
                const statusElement = document.getElementById(sensorType + 'Status');

                if (displayElement) {
                    let displayValue = '--';
                    if (!sensor.loading && sensor.value !== null) {
                        displayValue = sensor.value + getSensorUnit(sensorType);
                    }
                    displayElement.textContent = displayValue;
                    displayElement.style.color = getSensorColor(sensorType, sensor.value);
                }

                if (statusElement) {
                    const status = getSensorStatus(sensorType, sensor.value);
                    statusElement.textContent = status;
                    statusElement.className = 'value-status ' + getStatusClass(status);
                }
            });

            if (!animationRunning) {
                startAnimation();
            }
        }

        // Animation loop
        function animateCanvases() {
            animationTime += 1;

            // Only draw visualizations for currently visible sensors
            const currentPageSensors = sensorPages[currentPage];
            if (currentPageSensors && Array.isArray(currentPageSensors)) {
                currentPageSensors.forEach((sensorType, index) => {
                    const canvasId = sensorType + 'Canvas';
                    const container = document.getElementById(sensorType + 'Container');

                    // Only draw if container is visible
                    if (container && container.classList.contains('visible')) {
                        try {
                            drawVisualization(canvasId, sensorType, index * Math.PI/3);
                        } catch (error) {
                            console.error(`Error animating canvas ${canvasId}:`, error);
                        }
                    }
                });
            }

            if (animationRunning) {
                requestAnimationFrame(animateCanvases);
            }
        }

        function startAnimation() {
            if (!animationRunning) {
                console.log('Starting animation...');
                animationRunning = true;
                animateCanvases();
            }
        }

        function stopAnimation() {
            animationRunning = false;
        }

        // DateTime functions
        function updateDateTime() {
            const now = new Date();

            const timeOptions = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            };

            const dateOptions = {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            };

            const timeString = now.toLocaleTimeString('en-US', timeOptions);
            const dateString = now.toLocaleDateString('en-US', dateOptions);

            const timeElement = document.getElementById('currentTime');
            const dateElement = document.getElementById('currentDate');

            if (timeElement) {
                timeElement.textContent = timeString;
            }

            if (dateElement) {
                dateElement.textContent = dateString;
            }
        }

        function startDateTimeUpdates() {
            console.log('Starting datetime updates...');
            updateDateTime();
            dateTimeInterval = setInterval(updateDateTime, 1000);
        }

        function stopDateTimeUpdates() {
            if (dateTimeInterval) {
                clearInterval(dateTimeInterval);
            }
        }

        // Enhanced data update method with debugging
        function updateAllSensorData() {
            console.log('=== FETCHING SENSOR DATA ===');
            console.log('Request URL:', window.location.origin + '/Home/GetDeviceData');

            fetch('/Home/GetDeviceData', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                credentials: 'same-origin'
            })
            .then(response => {
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                console.log('Response URL:', response.url);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}, statusText: ${response.statusText}`);
                }

                // Check if response is actually JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error(`Expected JSON response but got: ${contentType}`);
                }

                return response.json();
            })
            .then(data => {
                console.log('Received data:', data);
                console.log('Data type:', typeof data);
                console.log('Data keys:', Object.keys(data));

                if (data.success) {
                    // Log debug info if available
                    if (data.debug) {
                        console.log('Debug info:', data.debug);
                    }

                    // Update temperature
                    if (data.data.temperature !== null && data.data.temperature !== undefined) {
                        sensorData.temperature.value = parseFloat(data.data.temperature).toFixed(1);
                        sensorData.temperature.loading = false;
                        console.log('Temperature updated:', sensorData.temperature.value);
                    } else {
                        console.warn('Temperature data is null/undefined');
                        sensorData.temperature.value = 'Error';
                        sensorData.temperature.loading = false;
                    }

                    // Update air quality
                    if (data.data.overallApi !== null && data.data.overallApi !== undefined) {
                        sensorData.api.value = Math.round(data.data.overallApi).toString();
                        sensorData.api.loading = false;
                        console.log('API updated:', sensorData.api.value);
                    } else {
                        console.warn('OverallAPI data is null/undefined');
                        sensorData.api.value = 'Error';
                        sensorData.api.loading = false;
                    }

                    // Update humidity
                    if (data.data.humidity !== null && data.data.humidity !== undefined) {
                        sensorData.humidity.value = Math.round(data.data.humidity).toString();
                        sensorData.humidity.loading = false;
                        console.log('Humidity updated:', sensorData.humidity.value);
                    } else {
                        console.warn('Humidity data is null/undefined');
                        sensorData.humidity.value = 'Error';
                        sensorData.humidity.loading = false;
                    }

                    // Update pH
                    if (data.data.ph !== null && data.data.ph !== undefined) {
                        sensorData.ph.value = parseFloat(data.data.ph).toFixed(1);
                        sensorData.ph.loading = false;
                        console.log('pH updated:', sensorData.ph.value);
                    } else {
                        console.warn('pH data is null/undefined');
                        sensorData.ph.value = 'Error';
                        sensorData.ph.loading = false;
                    }

                    // Update solar
                    if (data.data.solar !== null && data.data.solar !== undefined) {
                        sensorData.solar.value = parseFloat(data.data.solar).toFixed(1);
                        sensorData.solar.loading = false;
                        console.log('Solar updated:', sensorData.solar.value);
                    } else {
                        console.warn('Solar data is null/undefined');
                        sensorData.solar.value = 'Error';
                        sensorData.solar.loading = false;
                    }

                    updateUI();
                } else {
                    console.error('Server returned success=false:', data.message);
                    if (data.error) console.error('Server error details:', data.error);
                    if (data.stackTrace) console.error('Server stack trace:', data.stackTrace);

                    Object.keys(sensorData).forEach(key => {
                        sensorData[key].value = 'Error';
                        sensorData[key].loading = false;
                    });
                    updateUI();
                }
            })
            .catch(error => {
                console.error('Fetch error details:');
                console.error('Error type:', error.constructor.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                console.error('Full error object:', error);

                Object.keys(sensorData).forEach(key => {
                    sensorData[key].value = 'Error';
                    sensorData[key].loading = false;
                });
                updateUI();
            });
        }

        // Error handlers
        window.addEventListener('error', function(e) {
            console.error('=== UNCAUGHT ERROR ===');
            console.error('Error:', e.error);
            console.error('Message:', e.message);
            console.error('Filename:', e.filename);
            console.error('Line:', e.lineno);
            console.error('Column:', e.colno);
        });

        window.addEventListener('unhandledrejection', function(e) {
            console.error('=== UNHANDLED PROMISE REJECTION ===');
            console.error('Reason:', e.reason);
            console.error('Promise:', e.promise);
        });

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== DOM CONTENT LOADED ===');

            // Check if all elements exist
            const elementsOk = checkRequiredElements();
            if (!elementsOk) {
                console.error('Some required elements are missing! Stopping initialization.');
                return;
            }

            console.log('DateTime starting...');
            // Start datetime updates
            startDateTimeUpdates();
            console.log('DateTime updates started');

            // Show initial page
            console.log('Showing initial page...');
            setTimeout(() => {
                showPage(0);
            }, 200);
            console.log('Initial page shown');

            // Initial canvas drawings
            console.log('Setting up canvas drawings...');
            setTimeout(() => {
                console.log('Drawing initial canvases...');
                const currentPageSensors = sensorPages[currentPage];
                console.log('Current page sensors:', currentPageSensors);

                currentPageSensors.forEach((sensorType, index) => {
                    const canvasId = sensorType + 'Canvas';
                    console.log('Drawing canvas:', canvasId);
                    drawVisualization(canvasId, sensorType, index * Math.PI/3);
                });
                startAnimation();
                console.log('Animation started');
            }, 100);

            // Initial data updates
            console.log('Setting up data updates...');
            setTimeout(() => {
                console.log('=== FIRST DATA UPDATE CALL ===');
                updateAllSensorData();

                // Set up data refresh interval
                console.log('Setting up 30-second interval...');
                const intervalId = setInterval(() => {
                    console.log('=== INTERVAL DATA UPDATE CALL ===');
                    updateAllSensorData();
                }, 30000); // 30 seconds refresh

                console.log('Interval ID:', intervalId);

                // Setup configuration change monitoring
                console.log('Setting up configuration monitoring...');
                configCheckInterval = setInterval(() => {
                    checkConfigurationChanges();
                }, 10000); // 10 seconds

                // Get initial configuration timestamp
                getConfigurationTimestamp();
            }, 500);

            // Start page flipping after initial load
            setTimeout(() => {
                console.log('Starting page flipping...');
                startPageFlipping();
                console.log('Page flipping started');
            }, 3000); // Increased delay to ensure everything is loaded

            console.log('=== DOM CONTENT LOADED COMPLETE ===');
        });

        // Also check if document is already ready
        if (document.readyState === 'loading') {
            console.log('Document is still loading, waiting for DOMContentLoaded...');
        } else {
            console.log('Document already loaded, running initialization immediately...');
            // If DOM is already ready, trigger the event manually
            document.dispatchEvent(new Event('DOMContentLoaded'));
        }

        function getConfigurationTimestamp() {
            fetch('/Configuration/GetConfigurationTimestamp')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        lastConfigTimestamp = data.timestamp;
                        console.log('Initial config timestamp:', data.lastUpdated);
                    }
                })
                .catch(() => {
                    console.warn('Failed to get configuration timestamp');
                });
        }

        function checkConfigurationChanges() {
            fetch('/Configuration/GetConfigurationTimestamp')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.timestamp > lastConfigTimestamp) {
                        console.log('=== CONFIGURATION CHANGED ===');
                        console.log('New timestamp:', data.lastUpdated);
                        lastConfigTimestamp = data.timestamp;

                        // Reload sensor data immediately
                        console.log('Reloading sensor data due to config change...');
                        updateAllSensorData();
                    }
                })
                .catch(() => {
                    // Silently fail - don't spam console
                });
        }

        console.log('=== SCRIPT END ===');
    </script>
</body>
</html>
